Mqtt 1.3
1.	Импортируем библиотеку Paho MQTT для взаимодействия с Message queuing telemetry (MQTT) и библиотеку RPI.GPIO для управления GPIO пинами.

import paho.mqtt.client as mqtt
import RPi.GPIO as GPIO

2.	Объявляем переменную LED_PIN и присваиваем ей номер пина 17 (указываем ей 17 пин) на Raspberry PI.
 
LED_PIN = 17

3.	Устанавливаем режим нумерации пинов. Параметр GPIO.BCM означает, что мы будем использовать (Broadcom GPIO) внутреннюю нумерацию пинов Raspberry Pi.

GPIO.setmode(GPIO.BCM)

4.	Настраиваем пин, связанный со светодиодом (LEN_PIN, п. 2) как выходной. Это означает, что пин будет использоваться для отправи сигналов на светодиод
(вкл./выкл.).

GPIO.setup(LED_PIN, GPIO.OUT)
 
5.	Объявляем переменную led_state, и присваиваем ей булевое значение 0 (т. е. False), она будет хранить текущее состояние светодиода и изначально он 
будет выключен из-за False.

led_state = False

6.	Определяем функцию on_message, с тремя аргументами: client – экземпляр клиента, userdata – произвольные пользовательские данные, message- 
объект сообщения. Данная функция, которая будет автоматически всякий раз, когда принимается новое сообщение на подписанном канале.

def on_message(client, userdata, message):

7.	Объявляем глобальную переменную led_state (из п.5) внутри данной функции, чтобы иметь возможность к ней обращаться и изменять её.

global led_state

8.	Декодируем сообщение из формата байтов в строку с помощью кодировки UTF-8. Записываем текст в переменную msg.

msg = message.payload.decode("utf-8")

9.	После этого выводим сообщение (переменную msg из п.8) в консоль, чтобы увидеть, что именно было получено

print(f"Received message: {msg}")

10.	Так как мы получили сообщение, то присваиваем переменной led_state значение противоположное текущему (было False, станет True. Было True станет False)

led_state = not led_state

11.	Устанавливаем состояние выходного пина LED_PIN (из п.2). Если led_state равняется булевой единице (True), 
то устанавливаем высокий уровень (Vcc положительное напряжение) (GPIO.HIGH), 
в следствие чего светодиод загорается и если led_state равняется булевому нулю (False), 
то устанавливаем низкий уровень (GND, заземление) (GPIO.LOW), что выключит светодиод

GPIO.output(LED_PIN, GPIO.HIGH if led_state else GPIO.LOW)

12.	Выходим из функции из п.6
13.	Создаем новый экземпляр клиента MQTT. Он будет использоваться для подключения к брокеру и обмена сообщениями

client = mqtt.Client()

14.	Назначим ранее определенную функцию on_message (из п.6) для обработки сообщений, которые приходят от брокера.

client.on_message = on_message

15.	Определяем адрес брокера MQTT, к которому будем подключаться. Мы указали публичный тестовый брокер Mosquitto.

broker_address = "test.mosquitto.org"

16.	Подключаемся к брокеру, указывая его адрес и порт (1883 – порт по умолчанию для MQTT).

client.connect(broker_address, port=1883)

17.	Подписываемся на канал home/led, чтобы получать сообщения, отправленные в этот канал.

client.subscribe("home/led")

18.	Запускаем бесконечный цикл, который будет обрабатывать входящие сообщения и вызывать функцию on_message (из п.6), когда приходят сообщения

client.loop_forever()
